import { timingSafeEqual } from "crypto";

/** token expiration time: 5 minutes (300000ms) */
const TOKEN_EXPIRATION_MS = 300000;

export type TokenVerificationError =
  | "missing_secret"
  | "malformed_token"
  | "expired"
  | "invalid_signature";

export interface TokenVerificationResult {
  valid: boolean;
  userId?: string;
  error?: TokenVerificationError;
}

/**
 * extract token from authorization header (bearer token format).
 * returns null if not found in header - caller should check body as fallback.
 */
export function extractChatToken(req: Request): string | null {
  const authHeader = req.headers.get("authorization");
  if (authHeader?.startsWith("Bearer ")) {
    return authHeader.replace("Bearer ", "").trim();
  }
  return null;
}

/**
 * verify a chat token generated by convex.
 * must use the same secret as cHAT_aUTH_sECRET in convex.
 *
 * returns detailed error information for better error messages.
 */
export async function verifyChatToken(
  token: string
): Promise<TokenVerificationResult> {
  const secret = process.env.CHAT_AUTH_SECRET;

  if (!secret) {
    console.error("CHAT_AUTH_SECRET environment variable is not set");
    return { valid: false, error: "missing_secret" };
  }

  if (!token || token.trim().length === 0) {
    return { valid: false, error: "malformed_token" };
  }

  try {
    const decoded = atob(token);
    const parts = decoded.split(":");

    if (parts.length !== 3) {
      return { valid: false, error: "malformed_token" };
    }

    const [userId, timestampStr, signature] = parts;
    const timestamp = parseInt(timestampStr, 10);

    if (isNaN(timestamp)) {
      return { valid: false, error: "malformed_token" };
    }

    // check token is not expired (5 minute validity)
    const now = Date.now();
    if (now - timestamp > TOKEN_EXPIRATION_MS) {
      return { valid: false, error: "expired" };
    }

    // verify signature
    const data = `${userId}:${timestamp}`;
    const encoder = new TextEncoder();
    const key = await crypto.subtle.importKey(
      "raw",
      encoder.encode(secret),
      { name: "HMAC", hash: "SHA-256" },
      false,
      ["sign"]
    );
    const expectedSignature = await crypto.subtle.sign(
      "HMAC",
      key,
      encoder.encode(data)
    );
    const expectedHex = Array.from(new Uint8Array(expectedSignature))
      .map((b) => b.toString(16).padStart(2, "0"))
      .join("");

    // use timing-safe comparison to prevent timing attacks
    try {
      const sigBuffer = Buffer.from(signature, "hex");
      const expectedBuffer = Buffer.from(expectedHex, "hex");
      if (
        sigBuffer.length !== expectedBuffer.length ||
        !timingSafeEqual(sigBuffer, expectedBuffer)
      ) {
        return { valid: false, error: "invalid_signature" };
      }
    } catch {
      // invalid hex string
      return { valid: false, error: "invalid_signature" };
    }

    return { valid: true, userId };
  } catch {
    return { valid: false, error: "malformed_token" };
  }
}
